
//filepath: bootloader.asm
; ------------------------------------------------------------------
; bootloader.asm  (512 Bytes, letzter Wert 0xAA55)
; ------------------------------------------------------------------

bits 16
org 0x7C00

start:
    cli
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00
    sti

    ; GDT aufbauen und laden
    lgdt [gdt_descriptor]

    ; in Protected Mode schalten
    mov eax, cr0
    or  eax, 1
    mov  cr0, eax

    ; Far jump zu Protected Mode Code
    jmp CODE_SEG:pm_entry

; ------------------------------------------------------------------
; GDT
gdt_start:
    dq 0
gdt_code:
    dw 0xFFFF, 0x0000
    db 0x00, 10011010b, 11001111b
    db 0x00
gdt_data:
    dw 0xFFFF, 0x0000
    db 0x00, 10010010b, 11001111b
    db 0x00
gdt_end:

gdt_descriptor:
    dw gdt_end - gdt_start - 1
    dd gdt_start

CODE_SEG equ gdt_code - gdt_start
DATA_SEG equ gdt_data - gdt_start

; ------------------------------------------------------------------
bits 32
pm_entry:
    ; Segmente setzen
    mov ax, DATA_SEG
    mov ds, ax
    mov ss, ax
    mov esp, 0x90000

    ; Direkt zu Kernel springen (laut linker.ld bei 0x1000)
    jmp 0x1000

halt:
    cli
    hlt
    jmp halt

; Füllbytes + Signatur
times 510-($-$$) db 0
dw 0xAA55


//filepath: build.bat
@echo off
set NASM=nasm.exe
set CC=i686-elf-gcc.exe
@REM set CC=i686-w64-mingw32-gcc.exe
set LD=i686-elf-ld.exe
set OBJCOPY=i686-elf-objcopy.exe
set QEMU=qemu-system-i386.exe

rem 1) Assemble bootloader (as flat binary!)
%NASM% -f bin -o bootloader.bin bootloader.asm
if %ERRORLEVEL% neq 0 exit /b %ERRORLEVEL%

rem 2) Compile kernel to object
%CC% -ffreestanding -m32 -c kernel.c -o kernel.o
if %ERRORLEVEL% neq 0 exit /b %ERRORLEVEL%

rem 3) Link kernel to flat binary
%LD% -m elf_i386 -T linker.ld -o kernel.elf kernel.o
if %ERRORLEVEL% neq 0 exit /b %ERRORLEVEL%

rem 4) Extract kernel binary
%OBJCOPY% -O binary kernel.elf kernel.bin
if %ERRORLEVEL% neq 0 exit /b %ERRORLEVEL%

rem 5) Concatenate bootloader + kernel
copy /b bootloader.bin + kernel.bin os-image.bin > nul

rem 6) Run in QEMU
%QEMU% -drive format=raw,file=os-image.bin


//filepath: kernel.c
#include "stdlib.h"

void kernel_main(void)
{
    clear_screen();
    puts("Hello from simple OS!\n");

    puts("Press key to switch to graphics mode...");
    getkey();

    set_graphics_mode();      // VGA Mode 13h (320×200)
    putc_graphic(10, 10, 12); // gelber Pixel an (10,10)
    puts_graphic("Grafikmodus aktiv!\n", 20, 50, 15);

    while (1)
    {
        char c = getkey();
        if (c == 't')
        {
            set_text_mode();
            clear_screen();
            puts("Zurueck im Textmodus.\n");
            break;
        }
    }

    for (;;)
        __asm__("hlt");
}


//filepath: linker.ld
ENTRY(kernel_main)

SECTIONS
{
  . = 0x1000;
  .text : { *(.text) }
  .rodata : { *(.rodata) }
  .data : { *(.data) }
  .bss  : { *(.bss) }
}


//filepath: stdlib.c
#include "stdlib.h"

/* = Textmodus = */
volatile uint16_t *VGA = (uint16_t *)0xB8000;
int cursor = 0;

void clear_screen(void)
{
    for (int i = 0; i < 80 * 25; i++)
        VGA[i] = ' ' | (0x07 << 8);
    cursor = 0;
}

void putc(char c)
{
    if (c == '\n')
    {
        cursor += 80 - (cursor % 80);
    }
    else
    {
        VGA[cursor++] = c | (0x07 << 8);
    }
}

void puts(const char *s)
{
    while (*s)
        putc(*s++);
}

char getkey(void)
{
    /* BIOS Int16h real-mode geht nicht in Protected Mode.
       Stattdessen pollen wir PS/2-Controller: */
    while (!(inb(0x64) & 1))
        ;
    return inb(0x60);
}

/* = Grafikmodus = */
void set_graphics_mode(void)
{
    /* BIOS-Interrupt Mode 13h aufrufen (funktioniert nur in real/vm86). */
    __asm__ volatile(
        "mov $0x13, %%ax\n\t"
        "int $0x10"
        : : : "ax");
}

void set_text_mode(void)
{
    __asm__ volatile(
        "mov $0x03, %%ax\n\t"
        "int $0x10"
        : : : "ax");
}

uint8_t *FB = (uint8_t *)0xA0000;
void putc_graphic(int x, int y, uint8_t color)
{
    if (x < 0 || x >= 320 || y < 0 || y >= 200)
        return;
    FB[y * 320 + x] = color;
}

void puts_graphic(const char *s, int x, int y, uint8_t color)
{
    while (*s)
    {
        putc_graphic(x++, y, color);
        s++;
        if (x >= 320)
        {
            x = 0;
            y++;
        }
    }
}


//filepath: stdlib.h
#ifndef _STDLIB_H
#define _STDLIB_H

#include <stdarg.h>
#include <stdint.h>

/* Textmodus (80×25, 0xB8000) */
void clear_screen(void);
void putc(char c);
void puts(const char *s);
char getkey(void);

/* Grafikmodus (Mode 13h, 320×200, 0xA0000) */
void set_graphics_mode(void);
void set_text_mode(void);
void putc_graphic(int x, int y, uint8_t color);
void puts_graphic(const char *s, int x, int y, uint8_t color);

/* Low‐level I/O */
static inline void outb(uint16_t port, uint8_t val)
{
    __asm__ volatile("outb %0, %1" : : "a"(val), "Nd"(port));
}
static inline uint8_t inb(uint16_t port)
{
    uint8_t ret;
    __asm__ volatile("inb %1, %0" : "=a"(ret) : "Nd"(port));
    return ret;
}

#endif

